from flask import Blueprint, render_template, request, redirect, url_for, jsonify
from app.models import Utility, Expense, Gas
from app import db
from datetime import datetime
import matplotlib.pyplot as plt
import io
import base64
import matplotlib.dates as mdates

#creating a blueprint named routes
bp = Blueprint('routes', __name__)

@bp.route('/')
def home():
    """
    Extracts information from each database and creates lists which are used to create different graphs in home.html.

    Returns:
    A rendered home page with different graphs analysing spending from each of the routes.
    """

    # Expense Database
    expense_data = Expense.query.order_by(Expense.date).all()       # Orders all entries by the date

    # Making arrays of dates prices and description
    expense_dates = [expense.date.strftime('%m/%d') for expense in expense_data]
    expense_values = [expense.price for expense in expense_data]
    expense_descriptions = [expense.description for expense in expense_data]

    # Combines the expenses with the same date
    # If there is an entry for that date, add to existing total and item description else make a new entry
    # Use the date as the key and the price/description as its values
    expense_dict = {}
    for date, price, description in zip(expense_dates, expense_values, expense_descriptions):       # Zip the lists together to form tuples in the format (date, price, description)
        if date in expense_dict:
            expense_dict[date]['total'] += price
            expense_dict[date]['items'].append(f"{description}: ${price:.2f}")      
        else:
            expense_dict[date] = {'total': price, 'items': [f"{description}: ${price:.2f}"]}     

    # Separate the formatted data from the dictionary into lists for chart creation
    expense_date_labels = list(expense_dict.keys())
    expense_total_values = [value['total'] for value in expense_dict.values()]
    expense_breakdown = [value['items'] for value in expense_dict.values()]     # For the tooltip message to display what made up the total cost

    # --------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Utility Database

    # Extracting all entries of the current month (as an integer) from database by looking up the start date 
    utility_data = Utility.query.filter(db.extract('month', Utility.electric_start_date) == datetime.now().month).all()

    # Converts the strings to floats and sums it up
    # Workaround: Usually each entry is just 1 number but to not pass it as an array we use the sum() to make it into a number 
    electric = sum([float(utility.electric) for utility in utility_data])
    water = sum([float(utility.water) for utility in utility_data])
    internet = sum([float(utility.internet) for utility in utility_data])

    # Lists for chart creation
    pie_chart_labels = ['Water', 'Internet', 'Electric']
    pie_chart_values = [water, internet, electric]

    # --------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Gas Database





    # reason why we zip and sort together is to ensure that the price is associated with the correct date
    # if we just sorted the lists as is the price would not match with the correct date
    # sorted_expenses = sorted(zip(expense_dates, expense_prices), key=lambda x: x[0])  # Sort by date
    # expense_dates, expense_prices = zip(*sorted_expenses)  # Unzip sorted data

    # Plotting expense data

    # # creates a figure and axis
    # fig, ax = plt.subplots()
    # # dates = x axis and price = y axis. marker linestyle and color is just to represent what the plots would look like 
    # ax.scatter(expense_dates, expense_prices, color='g')
    # # ax.plot(expense_dates, expense_prices, marker='o', linestyle='-', color='g')

    # # Format dates to avoid overlap, rotate them and display as 'MMM dd'
    # ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))  # E.g., 'Sep 01'
    # ax.xaxis.set_major_locator(mdates.DayLocator())  # Show every day
    # plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels to make them readable

    # ax.set_title(f'Expenses for {datetime.now().strftime("%B")} (up to today)')
    # ax.set_xlabel('Date')
    # ax.set_ylabel('Price')
    # # creates a binary stream of the data and then saves that binary stream into png form
    # expense_img = io.BytesIO()
    # plt.savefig(expense_img, format='png')
    # expense_img.seek(0)
    # # converts binary data into a string 
    # expense_plot_url = base64.b64encode(expense_img.getvalue()).decode()
    # plt.close()

    # --------------------------------------------------------------------------------------------------------------------------------------------------------------------


    # fig, ax = plt.subplots()
    # ax.pie(pie_chart_values, labels=pie_chart_labels, autopct='%1.1f%%', startangle=90, colors=['#ff9999','#66b3ff','#99ff99','#ffcc99'])
    
    # # makes the divided sections equal
    # ax.axis('equal')
    # pie_img = io.BytesIO()
    # plt.savefig(pie_img, format='png')
    # pie_img.seek(0)
    # # converts binary data into a string 
    # pie_plot_url = base64.b64encode(pie_img.getvalue()).decode()
    # plt.close()

    # --------------------------------------------------------------------------------------------------------------------------------------------------------------------

    # Gas Database
    # db.extract('month', Gas.date) extracts the month from gas.date and labels those entries with month
    # db.func.sum(Gas.price) sums up all the gas prices from that month and labels it total spending
    # group_by(db.extract('month', Gas.date)).all() allows me to retrieve all the entries with the same month together 
    gas_data = db.session.query(db.extract('month', Gas.date).label('month'), db.func.sum(Gas.price).label('total_spending')).group_by(db.extract('month', Gas.date)).all()

    # so the data now has the labels month and total spending 
    # going to create a list of each
    
    # to display the months where i data for i am going to create a list of the months i have, another list containing all the month names, and finally create a list of labels of the months i have data for

    # to display the months where i data for i am going to create a list of the months i have, another list containing all the month names, and finally create a list of labels of the months i have data for
    # instead of displaying all the months of the year, i want to display the months i have data for

    month_names = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']    #list of months in the year
    months = [int(record.month) for record in gas_data]     #converts the months into an integer
    month_labels = [month_names[month-1] for month in months]   #labels for chart for the months there is data for
    total_spending = [record.total_spending for record in gas_data]   # list of total spending 


    # month_labels_str = str([f"{label}" for label in month_labels])

    # fig, ax = plt.subplots()
    # ax.bar(month_labels, monthly_gas_cost, color='skyblue')
    # ax.set_title('Gas Spending')
    # ax.set_xlabel('Month')
    # ax.set_ylabel('Cost')
    # plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels 


    # gas_img = io.BytesIO()
    # plt.savefig(gas_img, format='png')
    # gas_img.seek(0)
    # gas_plot_url = base64.b64encode(gas_img.getvalue()).decode()
    # plt.close()

    return render_template(
        'home.html', 
        month_labels=month_labels, 
        total_spending=total_spending, 
        pie_chart_values=pie_chart_values,
        pie_chart_labels=pie_chart_labels,
        expense_date_labels=expense_date_labels,
        expense_total_values=expense_total_values,
        expense_breakdown = expense_breakdown
    )


@bp.route('/utilities', methods=['GET', 'POST'])
def add_utilities():

    #accessing all entries of the database
    utilities = Utility.query.all()

    #when the user submits a form grab that data
    if request.method == 'POST':
        electric = float(request.form.get('electric'))
        water = float(request.form.get('water'))
        internet = float(request.form.get('internet'))
        household_items = request.form.get('household_items')

        #handling when the field is empty
        if household_items == '' or household_items is None:
            household_items = 0.0
        else:
            household_items = float(household_items)

        electric_start_date = datetime.strptime(request.form.get('electric_start_date'), '%Y-%m-%d').date()
        electric_end_date = datetime.strptime(request.form.get('electric_end_date'), '%Y-%m-%d').date()

        water_start_date = datetime.strptime(request.form.get('water_start_date'), '%Y-%m-%d').date()
        water_end_date = datetime.strptime(request.form.get('water_end_date'), '%Y-%m-%d').date()

        internet_start_date = datetime.strptime(request.form.get('internet_start_date'), '%Y-%m-%d').date()
        internet_end_date = datetime.strptime(request.form.get('internet_end_date'), '%Y-%m-%d').date()

        utility_split = round((electric + water + internet + household_items)/5, 2)

        summary = {
            'electric': electric,
            'water': water,
            'internet': internet,
            'household_items': household_items,
            'total_cost': (electric + water + internet + household_items),
            'ava_owes': utility_split,
            'jess_owes': utility_split,
            'annica_owes': utility_split,
            'april_owes': utility_split
        }

        # creating and saving new utility object
        new_utility = Utility(
            electric=electric, 
            water=water, 
            internet=internet, 
            household_item=household_items,
            electric_start_date=electric_start_date,
            electric_end_date=electric_end_date,
            water_start_date=water_start_date,
            water_end_date=water_end_date,
            internet_start_date=internet_start_date,
            internet_end_date=internet_end_date
            )
        db.session.add(new_utility)
        db.session.commit()

        utilities = Utility.query.all()

        # return redirect(url_for('routes.add_utilities'))
        return render_template('utility.html', utilities=utilities, summary=summary )

    #if no form has been submitted the page will be a blank slate
    return render_template('utility.html', utilities=utilities)

@bp.route('/add_expense', methods=['GET','POST'])
def add_expense():
    if request.method == "POST":
        descriptionList = request.form.getlist('description')
        priceList = request.form.getlist('price')
        dateList = request.form.getlist('date')
        cardList = request.form.getlist('card')

        total_spending = 0

        for i in range(len(priceList)):
            if priceList[i]:
                total_spending += float(priceList[i])

                # SQLite needs the date to be a Python object so we need to convert the string to a datetime object
                date_object = datetime.strptime(dateList[i], '%Y-%m-%d').date()

                new_expense = Expense(
                    description=descriptionList[i],
                    price=float(priceList[i]),
                    card_used=cardList[i],
                    date=date_object
                )

                db.session.add(new_expense)
        
        db.session.commit()
        return render_template('expense.html', total_spending=total_spending)

    return render_template('expense.html', total_spending=0)


@bp.route('/add_gas', methods=['GET','POST'])
def add_gas():
    #when the user submits the form
    if request.method == "POST":

        #gets all the prices from the form as a list of strings
        stationList = request.form.getlist('station')
        priceList = request.form.getlist('price')
        dateList = request.form.getlist('date')
        cardList = request.form.getlist('card')

        total_price = 0

        for i in range(len(priceList)):
            if priceList[i]:
                total_price += float(priceList[i])

                date_object = datetime.strptime(dateList[i], '%Y-%m-%d').date()

                new_gas = Gas(
                    station=stationList[i],
                    price=priceList[i],
                    card_used=cardList[i],
                    date=date_object
                )

                db.session.add(new_gas)
        
        db.session.commit()

        split_price = round(total_price / 2, 2)

        return render_template('gas.html', split_price=split_price, total_price=total_price)
    
    return render_template('gas.html', split_price=0, total_price=0)

